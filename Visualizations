import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from DSPI_v2 import DSPI_v2
from DSPI_valid_rho import DSPI_valid_rho
from DSPI_Upperlimit import DSPI_Upperlimit
from DSPI_Lowerlimit import DSPI_Lowerlimit
from DSPI_inverse import DSPI_inverse
from DSPI import DSPI
import DutchDraw as DutchDraw

# %% Experiment different Beta values

# Settings
M = 40 
P = 3
rho = 0

metric = "FBETA"

y_true = [1] * P + [0] * (M - P)

results = []
for alpha in np.linspace(0, 1):
    for b in [0.001, 0.1, 0.5, 1, 2, 5, 10, 20, 50, 10000, np.inf]:
        score = DSPI_v2(y_true, metric, alpha, rho, beta = b)
        results.append([alpha, b, score])
        
df = pd.DataFrame(results, columns = ["Alpha", "Metric", "Score"])

plt.figure(figsize = (10,10))
for metric, group, in df.groupby("Metric"):
    plt.plot(group["Alpha"], group["Score"], label = metric)
plt.xlabel(r'$\alpha$')
plt.ylabel(r'$F_\beta$')
plt.legend()
plt.show()

# %% Plot 1

M = 40 
P = 9
rho = 0.0

metric_options = ["PPV", "NPV", "ACC", "BACC", "FBETA", "MCC", "J", "MK", "KAPPA", "TS", "FM"]

y_true = [1] * P + [0] * (M - P)

results = []
for metric in metric_options:
    baseline = DutchDraw.optimized_baseline_statistics(y_true, metric)['Max Expected Value']    
    upper_limit = DSPI_Upperlimit(y_true, metric, rho)
    for s in np.linspace(baseline, upper_limit): 
        alpha, thetaopts = DSPI_inverse(y_true, metric, s, rho)
        score_v1 = DSPI(y_true, metric, alpha, thetaopts, rho)
        results.append([metric, M, P, baseline, upper_limit, rho, alpha, s, score_v1])

df = pd.DataFrame(results, columns = ["Metric", "M", "P", "Baseline", "Upper Bound", "rho", "Alpha", "Score", "Score_v1"])

plt.figure(figsize = (10,10))
for metric, group, in df.groupby("Metric"):
    plt.plot(group["Alpha"], group["Score"], label = metric)
plt.xlabel(r'$\alpha$')
#plt.ylabel(r"DSPI")
plt.ylabel(r"$\mu_{\alpha}$")
plt.ylim(0,1)
plt.legend()
plt.show()

#%% Plot 2 Scaler Directly

M = 40 
P = 3
rho = 0.05

metric_options = ["PPV", "NPV", "ACC", "BACC", "FBETA", "J", "KAPPA", "FM", "TS"]
#metric_options = ["FBETA"]

y_true = [1] * P + [0] * (M - P)

results = []
for metric in metric_options:
    UB = DSPI_Upperlimit(y_true, metric, rho)
    LB = DSPI_Lowerlimit(y_true, metric)
    for alpha in np.linspace(0,1): 
        score = DSPI_v2(y_true, metric, alpha, rho)
        score_scaled = (score - LB) / (UB - LB)
        results.append([metric, M, P, rho, alpha, score_scaled])

df = pd.DataFrame(results, columns = ["Metric", "M", "P", "rho", "Alpha", "Score"])

plt.figure(figsize = (10,10))
for metric, group, in df.groupby("Metric"):
    plt.plot(group["Alpha"], group["Score"], label = metric)
plt.ylabel(r'$\frac{\mu_\alpha - \mu_0}{\mu_1 - \mu_0}$')
plt.xlabel(r'$\alpha$')
plt.xlim(0,1)
plt.ylim(0,1)
plt.show()

# %% Plot 3 Scaler Indirectly

M = 40 
P = 3
rho = 0.04

metric_options = ["PPV", "NPV", "ACC", "BACC", "FBETA", "MCC", "J", "MK", "KAPPA", "TS", "FM"]
#metric_options = ["FBETA"]

y_true = [1] * P + [0] * (M - P)

results = []
for metric in metric_options:
    UB = DSPI_Upperlimit(y_true, metric, rho)
    LB = DSPI_Lowerlimit(y_true, metric)
    for s in np.linspace(LB, UB): 
        alpha, thetaopts = DSPI_inverse(y_true, metric, s, rho)
        score = DSPI(y_true, metric, alpha, thetaopts, rho)
        score_scaled = (score - LB) / (UB - LB)
        results.append([metric, M, P, rho, alpha, score_scaled])

df = pd.DataFrame(results, columns = ["Metric", "M", "P", "rho", "Alpha", "Score"])

plt.figure(figsize = (10,10))
for metric, group, in df.groupby("Metric"):
    plt.plot(group["Alpha"], group["Score"], label = metric)
plt.ylabel(r'$\frac{\mu_\alpha - \mu_0}{\mu_1 - \mu_0}$')
plt.xlabel(r'$\alpha$')
plt.legend()
plt.xlim(0,1)
plt.ylim(0,1)
plt.show()

# %% plot 4 Effect Rho

M = 10 
P = 4

metric = "FM"

y_true = [1] * P + [0] * (M - P)

results = []

upper_rho = DSPI_valid_rho(y_true, metric)
for rho in np.linspace(0, upper_rho, 10)[:-1]:
    UB = DSPI_Upperlimit(y_true, metric, rho)
    LB = DSPI_Lowerlimit(y_true, metric)
    for alpha in np.linspace(0,1): 
        score = DSPI_v2(y_true, metric, alpha, rho)
        score_scaled = (score - LB) / (UB - LB)
        results.append([M, P, rho, alpha, score, score_scaled])

df = pd.DataFrame(results, columns = ["M", "P", "rho", "Alpha", "Score", "Scaled-Score"])

plt.figure(figsize = (10,10))
for r, group, in df.groupby("rho"):
    plt.plot(group["Alpha"], group["Score"], label = r)
plt.ylabel(r'$\mu_\alpha$')
plt.xlabel(r'$\alpha$')
plt.legend()
plt.xlim(0,1)
plt.ylim(0,1)
plt.show()


plt.figure(figsize = (10,10))
for r, group, in df.groupby("rho"):
    plt.plot(group["Alpha"], group["Scaled-Score"], label = r)
plt.ylabel(r'$\frac{\mu_\alpha - \mu_0}{\mu_1 - \mu_0}$')
plt.xlabel(r'$\alpha$')
plt.legend()
plt.xlim(0,1)
plt.ylim(0,1)
plt.show()



